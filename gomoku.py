# -*- coding: utf-8 -*-
"""Gomoku.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vPSHLCoFrESHUX61PTnbQt4pgsmnBBIM
"""

# -*- coding: utf-8 -*-
"""
Created on Sat May 14 01:11:40 2022

@author: matte
"""
import time
import numpy as np
import string
from copy import deepcopy
alpha=["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"]


class Game:
    def __init__(self,grille=None):
        """Initialise plateau de jeu 15x15"""
        #L=[ [0]*15 for j 8in range(15)]
        L=np.zeros([15,15])
        
        self.grille=L
        
    def GrilleJeu(self): #pour afficher la grille
        """Affichage grille de jeu"""
        alphab=string.ascii_uppercase
        #colonne (1-15)
        L=[i for i in range(1,11)]
        print("\t  ",*L,sep="  ",end=" ")
        L=[i for i in range(11,16)]
        print(*L,sep=" ")

        for i in range(len(self.grille)):
            #ligne (A-O)
            print("\t",alphab[i],end=" ")
            for j in range(len(self.grille)):
                if self.grille[i][j]==0:
                    print('|-',end=" ")
                if self.grille[i][j]==1:
                    print('|X',end=" ")
                if self.grille[i][j]==2:
                    print('|O',end=" ")
                if j==14:
                    print('|')
        print()

    def tourIA(self,tour, joueurLocal,joueurAdverse,maxDepth):

        print("L'IA joue...")
        #Condition au 3e tour --> IA devra jouer en dehors du carré 7x7 de centre H8
        if tour==2:
           tmp = insertion(self.grille, 11, 11, tour%2+1)
           self.grille=tmp
           print("l'IA joue en ",alpha[11],12)
        else:
          (i, j, s) = minimax(self.grille, maxDepth, -float('inf'), float('inf'), True,joueurLocal,joueurAdverse)
          print("l'IA joue en ",alpha[i],j+1)
          tmp = insertion(self.grille, i, j, tour%2+1)
          self.grille=tmp
        s=abs(evaluate(self.grille,joueurLocal,joueurAdverse))
        print(s)
        if s==1000:
          return False
        else:
          return True
       
    

    def tourAdverse(self,tour,joueurLocal,joueurAdverse):
        
        print(tour)
        x= input("Entrez ligne : ").upper()
        y=int(input("Entrez colonne : "))
        i=alpha.index(x)
        j=y-1
     
        tmp= insertion(self.grille, i, j, tour%2+1)
        self.grille=tmp
        s=abs(evaluate(self.grille,joueurLocal,joueurAdverse))
        print(s)
        if s==1000:
         
          return False
        else:
          return True
     
    def play(self):
        """définit les joueurs et boucle du jeu"""
        joueurLocal = -1
        joueurAdverse = -1
        maxDepth=2
        tour=0
        IA=int(input("l'IA commence ? (0 ou 1) : ")) # IA=1 si l'IA joue en premier sinon IA = 0
        if IA == 0:
            joueurLocal = 2
            joueurAdverse = 1
        else:    
            joueurLocal = 1
            joueurAdverse = 2
  
            tmp=insertion(self.grille,7,7,tour%2+1)# si l'IA joue en premier, il doit joueur en [7,7]
          
            self.grille=tmp
            tour+=1
            
            #boucle du jeu
        a=True
        b=True
        while a==True and tour<=120:
            self.GrilleJeu()
            
            b=self.tourAdverse(tour,joueurLocal,joueurAdverse)
            if b==False: break
            tour+=1
            self.GrilleJeu()
            t1=time.time()
            a=self.tourIA(tour,joueurLocal,joueurAdverse,maxDepth)
            t2=time.time()
            print('temps écoulé',t2-t1)

            tour+=1
        self.GrilleJeu()
        if tour>120: print('Match nul : tous les pions ont été joués')
        if a==False: print("VICTOIRE DE l'IA !!!")
        if b==False: print("Victoire de l'adversaire.")


#on vérifie que la case est vide et qu'il y a soit des "X" soit des "O" autour'

def ifCaseDispo(grille, a, b):
    """Renvoie True si il y a des pions autour de la case [a,b], False sinon"""
    for i in range(-1,2):
        for j in range(-1,2):
            
            if (i != 0 or j != 0) and a+i >= 0 and a+i <15 and b+j >= 0 and b+j <15 and grille[a][b] == 0:
                
                if grille[a+i][b+j] != 0:
                    return True
    return False

def contour(grille):
    """Grille de booléen"""
    boolGrille = []

    for i in range(0, len(grille)):
        boolGrille.append([])
        for j in range(0,len(grille)):
            boolGrille[i].append(ifCaseDispo(grille, i, j))
    
        
    return boolGrille

def coordDispo(grille):
    """renvoie une liste de coordonées jouables"""
    boolGrille = contour(grille)
    coord = []
    for i in range(0,len(boolGrille)):
        for j in range(0, len(boolGrille[i])):
            if boolGrille[i][j] == True:
                coord.append([i,j])
    return coord

def insertion(game, i, j, idJoueur):
    tmp =deepcopy(game)
    if tmp[i][j] == 0:
        if idJoueur==2:
            tmp[i][j]=idJoueur
            return tmp
        if idJoueur==1:
            tmp[i][j]=idJoueur
            return tmp
        
    return [] # si la case n'est pas libre


def pionsConsecutifs(game, i, j, dirX, dirY):
    """retourne nb de pions alignés selon direction donnée"""
    couleur = int()
    nbPions = int()
    
    couleur = game[i][j]
    nbPions = 0
    
    lastCase = game[i][j]
    while lastCase == couleur:
        nbPions += 1
        i += dirY
        j += dirX
        if i < 0 or i >=15: return nbPions
        if j < 0 or j >= 15: return nbPions
        lastCase = game[i][j]
    
    if nbPions == 3 and lastCase != couleur and lastCase != 0: return 0 # si la derniere case est occupée par l'adversaire
    return nbPions


def pionsAlignes(game, i, j):
    nbPions = 1
    if game[i,j] != 0:
        nbPions = max(nbPions, pionsConsecutifs(game, i, j, 1, 1))
        nbPions = max(nbPions, pionsConsecutifs(game, i, j, 1, 0))
        nbPions = max(nbPions, pionsConsecutifs(game, i, j, 1, -1))
        nbPions = max(nbPions, pionsConsecutifs(game, i, j, 0, 1))
        nbPions = max(nbPions, pionsConsecutifs(game, i, j, -1, -1))
        nbPions = max(nbPions, pionsConsecutifs(game, i, j, -1, 0))
        nbPions = max(nbPions, pionsConsecutifs(game, i, j, -1, 1))
        nbPions = max(nbPions, pionsConsecutifs(game, i, j, 0, -1))
    
    return nbPions

def evaluate(game,joueurLocal,joueurAdverse):
    #if len(game) == 0: return -float('inzoomf')
    evaluate = 0
    for i in range(len(game)):
        for j in range(15):
            if game[i,j] == joueurLocal:
                nbPions = pionsAlignes(game, i, j)
                if nbPions>=5:
                  return 1000
                else:
                    evaluate += nbPions-1
            elif game[i,j]==joueurAdverse:
                nbPions = pionsAlignes(game, i, j)
                if nbPions>=5:
                  return -1000
                else:
                    evaluate -= nbPions-1
                    
    return evaluate

#maxDepth = 3
def minimax(game, depth, alpha, beta, maximize,joueurLocal,joueurAdverse):
    gameevaluate = evaluate(game,joueurLocal,joueurAdverse)
    if depth == 0 or abs(gameevaluate) == 1000: # si on arrive à la profondeur 0 ou que un joueur a gagné
        return (-1, -1, gameevaluate)

    #liste des différentes futures grilles possibles 
    nextGames = []
    coord = coordDispo(game)
    for i in coord:
        nextGames.append(insertion(game, i[0], i[1], (joueurLocal if maximize==True else joueurAdverse)))

    compteur = 0
    if maximize:
      #on évalue chaque futurs grilles possibles
        evaluates = []
        for nextGame in nextGames:
            if (len(nextGame) == 0):
                evaluates.append(-float('inf')) #si la colonne est pleine
                continue
            if beta > alpha:
                (i, j, nextGameevaluate) = minimax(nextGame, depth-1, alpha, beta, False,joueurLocal,joueurAdverse)
                evaluates.append(nextGameevaluate)
                if evaluate(nextGame,joueurLocal,joueurAdverse) == 1000 and depth == 2: # si on peut gagner directement
                    return (coord[compteur][0], coord[compteur][1], nextGameevaluate*100)
                compteur += 1
                
                alpha = max(alpha, nextGameevaluate)
        #on récupère 
        index = np.argmax(evaluates)
        return (coord[index][0], coord[index][1], max(evaluates))
    else:
        evaluates = []
        for nextGame in nextGames:
            if (len(nextGame) == 0):
                evaluates.append(float('inf')) #si la colonne est pleine
                continue
            if beta > alpha:
                (i, j, nextGameevaluate) = minimax(nextGame, depth-1, alpha, beta, True,joueurLocal,joueurAdverse)
                evaluates.append(nextGameevaluate)
                if evaluate(nextGame,joueurLocal,joueurAdverse) == -1000 and depth == 1: # si l'adversaire peut gagner directement
                    return (coord[compteur][0], coord[compteur][1], nextGameevaluate*100)
                compteur += 1
                
                beta = min(beta, nextGameevaluate)
        
        index = np.argmin(evaluates)
        return (coord[index][0], coord[index][1], min(evaluates))
    




g=Game()
g.play()